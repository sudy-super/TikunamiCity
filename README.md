# 「チクナミシティ」街づくりプロジェクト
これは[「MIRAI都市」街づくりプロジェクト](https://hitachi-v2-service-6jrkee5ovq-an.a.run.app)とは何の関係もない架空のチクナミシティを舞台に街づくりを行うゲームです。
実在する組織、団体、ウェブサイト等とは一切関係ありません。

## 最大値探索アルゴリズム
### 問題の定式化
17個のソリューションそれぞれを「どの期 (P1/P2/P3) で達成するか」を決める割り当て問題です。一部のソリューションは達成しない選択肢もあるため、実質的には「どの部分集合を選び、各ソリューションをどの期に割り当てるか」を最適化します。

### 全体構造: 3フェーズのターゲット検証型探索
全 `4^17` (≒170億) 通りの探索は不可能なので、有望な部分集合に絞って `3^N` の期割り当てを探索する方式を採用しています。

- **Phase 1**: 全17ソリューション ( `3^17` ≒ 1.3億通り)
- **Phase 2**: 1つ除外した16ソリューション (最大17パターン x `3^16` ≒ 4300万)
- **Phase 3**: 2つ除外した15ソリューション (最大136パターン x `3^15` ≒ 1400万)

各フェーズで `maxPossible` (全ソリューションを最良の期で達成した場合の上限) が現時点の `globalBest` 以下なら即スキップします。

### DFS 探索 (`searchSubset`)
部分集合が与えられると、N個のソリューションに対し期 (1/2/3) を割り当てる 3^N の探索をDFSで行います。

**ソリューションの処理順序**: SP の最大値が大きい順にソートします。高価値のソリューションを先に決めることで、枝刈りの効果を高めます。

**期の試行順序**: socialPointsByPeriod を持つソリューションは SP が最大の期から試します (e.g. S7 は P2/P3 を先に試す)。

#### 枝刈り (pruning)
1. **SP上限枝刈り**: 現在の累積 SP + 残りソリューションの最大 SP 合計 (`suffixMax[idx]`) が `bestSocial` 以下なら打ち切り
2. **個別選択枝刈り**: 特定の期を選んだ後の SP + 残り上限が `bestSocial` 以下ならその期をスキップ
3. **総予算枝刈り (`quickBudgetPrune`)**: 全期間の総アップグレードコストが、最大予算 (120 + 全TP + 全売却収入240) を超えたら打ち切り
4. **期別予算枝刈り (`perPeriodPrune`)**: P1 単体、P1+P2 累計のコストが上限を超えたら打ち切り

枝刈り 3, 4 は2ノードごとに実行 (毎回やるとオーバーヘッドが大きいため)。

#### インクリメンタルな技術レベル追跡
DFS の各ノードで割り当てを変更するたびに `lvReq[tech][period]` を更新し、バックトラック時に `undoStack` で復元します。これにより期別の必要レベルを O(1) で参照でき、枝刈りを高速に実行できます。

### 予算チェック (`budgetCheck`) — 葉ノードでの正確な検証
DFS の葉 (全ソリューションに期を割り当て済み) で呼ばれ、実際にゲーム内で実行可能かを検証します。

#### 期ごとの処理

`予算 = 繰越TP + 期の基本TP (30/40/50) + 前期のpendingTP`

1. **Pre-sell**: P1 で、どのソリューションにも使われないテックを売却 (+20 each)
2. **売却対象の特定**: `lastPer[t] == p` のテックをリストアップ (その期が最後の使用期)
3. 簡易チェック: `予算 - 総コスト + 売却収入 < 0` なら即 false
4. **売却順序シミュレーション**: `checkSellOrdering` で全順列を検証

#### 売却順序シミュレーション (`checkSellOrdering`)
テックの売却には「そのテックを要求する全ソリューションの達成」が前提条件です。ソリューションは複数テックを要求するため、売却の順序によって利用可能な予算が変わります。

```
例: P3 で A, F, B を売却する場合

順序 A → F → B:
  A売却: A→4 に45消費, +20売却 → 残185 → 95 → ...
  F売却: L→5 に110消費, +20売却
  B売却: B→4(35)+C→5(80)=115 消費... 残90で足りない ❌

順序 A → F → G → B → C → L → K → J (正解):
  A売却: -45+20=185
  F売却: L→5で-110+20=95
  G売却: 0+20=115
  B売却: B→4+C→5で-115+20=20  ← ぎりぎり足りる ✓
  (以降 C,L,K,J の売却は追加コスト小)
```

アルゴリズムは再帰的に全順列を試します:

1. 売却テック `T` を1つ選ぶ
2. `T` を要求する全ソリューションの前提条件を満たすアップグレードコスト (batchCost) を計算
3. `予算 >= batchCost` なら `予算 -= batchCost; 予算 += 20` で再帰
4. 全売却完了後、残りのアップグレードコストが予算内か確認
売却テック数は1期あたり最大8個程度なので、最悪 `8!` = 40,320 通りですが、`budget < batchCost` による枝刈りで実際はごく少数しか探索しません。

### 計算量
| 層 | 計算量 |
| :-: | :-: |
| Phase 1-3 の部分集合数 | 最大 1 + 17 + 136 = 154 |
| 各部分集合の DFS | `3^N` (N=15~17), 枝刈りで大幅削減 |
| 葉ノードの budgetCheck | O(NT x NS) + 売却順列 (最大 ~8!) |
| 実測 | 全体で約10分、数億ノード探索 |
